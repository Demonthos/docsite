<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dioxus Router</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Example Project</li><li class="chapter-item expanded "><a href="example/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="example/first-route.html"><strong aria-hidden="true">2.</strong> Creating Our First Route</a></li><li class="chapter-item expanded "><a href="example/building-a-nest.html"><strong aria-hidden="true">3.</strong> Building a Nest</a></li><li class="chapter-item expanded "><a href="example/navigation-targets.html"><strong aria-hidden="true">4.</strong> Navigation Targets</a></li><li class="chapter-item expanded "><a href="example/redirection-perfection.html"><strong aria-hidden="true">5.</strong> Redirection Perfection</a></li><li class="chapter-item expanded "><a href="example/full-code.html"><strong aria-hidden="true">6.</strong> Full Code</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">7.</strong> Adding the Router to Your Application</a></li><li class="chapter-item expanded "><a href="reference/routes/index.html"><strong aria-hidden="true">8.</strong> Defining Routes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/routes/nested.html"><strong aria-hidden="true">8.1.</strong> Nested Routes</a></li></ol></li><li class="chapter-item expanded "><a href="reference/layouts.html"><strong aria-hidden="true">9.</strong> Layouts</a></li><li class="chapter-item expanded "><a href="reference/navigation/index.html"><strong aria-hidden="true">10.</strong> Navigation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/navigation/programmatic.html"><strong aria-hidden="true">10.1.</strong> Programmatic Navigation</a></li></ol></li><li class="chapter-item expanded "><a href="reference/history-providers.html"><strong aria-hidden="true">11.</strong> History Providers</a></li><li class="chapter-item expanded "><a href="reference/history-buttons.html"><strong aria-hidden="true">12.</strong> History Buttons</a></li><li class="chapter-item expanded "><a href="reference/static-generation.html"><strong aria-hidden="true">13.</strong> Static Generation</a></li><li class="chapter-item expanded "><a href="reference/routing-update-callback.html"><strong aria-hidden="true">14.</strong> Routing Update Callback</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Dioxus Router</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p>If you are not familiar with Dioxus itself, check out the <a href="https://dioxuslabs.com/docs/0.3/guide/en/">Dioxus book</a> first.</p>
</blockquote>
<p>Whether you are building a website, desktop app, or mobile app,
splitting your app's views into &quot;pages&quot; can be an effective method for
organization and maintainability.</p>
<p>For this purpose, Dioxus provides a router. Use the <code>cargo add</code> command to add the dependency:</p>
<pre><code class="language-sh">cargo add dioxus-router
</code></pre>
<p>This book is intended to get you up to speed with Dioxus Router. It is split
into two sections:</p>
<ol>
<li>The <a href="./reference/index.html">reference</a> section explains individual features in
depth. You can read it from start to finish, or you can read individual chapters
in whatever order you want.</li>
<li>If you prefer a learning-by-doing approach, you can check out the
<em><a href="./example/index.html">example project</a></em>. It guides you through
creating a dioxus app, setting up the router, and using some of its
functionality.</li>
</ol>
<blockquote>
<p>Please note that this is not the only documentation for the Dioxus Router. You
can also check out the <a href="https://docs.rs/dioxus-router/">API Docs</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>In this guide, you'll learn to effectively use Dioxus Router whether you're
building a small todo app or the next FAANG company. We will create a small
website with a blog, homepage, and more!</p>
<blockquote>
<p>To follow along with the router example, you'll need a working Dioxus app.
Check out the <a href="https://dioxuslabs.com/docs/0.3/guide/en/">Dioxus book</a> to get started.</p>
</blockquote>
<blockquote>
<p>Make sure to add Dioxus Router as a dependency, as explained in the
<a href="example/../index.html">introduction</a>.</p>
</blockquote>
<h2 id="youll-learn-how-to"><a class="header" href="#youll-learn-how-to">You'll learn how to</a></h2>
<ul>
<li>Create routes and render &quot;pages&quot;.</li>
<li>Utilize nested routes, create a navigation bar, and render content for a
set of routes.</li>
<li>Parse URL parameters to dynamically display content.</li>
<li>Redirect visitors to different routes.</li>
</ul>
<blockquote>
<p><strong>Disclaimer</strong></p>
<p>The example will only display the features of Dioxus Router. It will not
include any actual functionality. To keep things simple we will only be using
a single file, this is not the recommended way of doing things with a real
application.</p>
</blockquote>
<p>You can find the complete application in the <a href="example/./full-code.html">full code</a>
chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-our-first-route"><a class="header" href="#creating-our-first-route">Creating Our First Route</a></h1>
<p>In this chapter, we will start utilizing Dioxus Router and add a homepage and a
404 page to our project.</p>
<h2 id="fundamentals"><a class="header" href="#fundamentals">Fundamentals</a></h2>
<p>The core of the Dioxus Router is the [<code>Routable</code>] macro and the [<code>Router</code>] component.</p>
<p>First, we need an actual page to route to! Let's add a homepage component:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn Home(cx: Scope) -&gt; Element {
    render! {
        h1 { &quot;Welcome to the Dioxus Blog!&quot; }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="creating-routes"><a class="header" href="#creating-routes">Creating Routes</a></h2>
<p>We want to use Dioxus Router to separate our application into different &quot;pages&quot;.
Dioxus Router will then determine which page to render based on the URL path.</p>
<p>To start using Dioxus Router, we need to use the [<code>Routable</code>] macro.</p>
<p>The [<code>Routable</code>] macro takes an enum with all of the possible routes in our application. Each variant of the enum represents a route and must be annotated with the [<code>route(path)</code>] attribute.</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span>#![allow(non_snake_case)]
<span class="boring">fn main() {
</span>use dioxus::prelude::*;
use dioxus_router::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route(&quot;/&quot;)]
    // If the name of the component and variant are the same you can omit the component and props name
    // If they are different you can specify them like this:
    // #[route(&quot;/&quot;, ComponentName, PropsName)]
    Home {},
}
<span class="boring">}
</span></code></pre></pre>
<p>All other hooks and components the router provides can only be used as a descendant of a [<code>Router</code>] component.</p>
<p>If you head to your application's browser tab, you should now see the text
<code>Welcome to Dioxus Blog!</code> when on the root URL (<code>http://localhost:8080/</code>). If
you enter a different path for the URL, nothing should be displayed.</p>
<p>This is because we told Dioxus Router to render the <code>Home</code> component only when
the URL path is <code>/</code>.</p>
<h2 id="fallback-route"><a class="header" href="#fallback-route">Fallback Route</a></h2>
<p>In our example, when a route doesn't exist Dioxus Router doesn't render anything. Many sites also have a &quot;404&quot; page when a path does not exist. Let's add one to our site.</p>
<p>First, we create a new <code>PageNotFound</code> component.</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn PageNotFound(cx: Scope, route: Vec&lt;String&gt;) -&gt; Element {
    render! {
        h1 { &quot;Page not found&quot; }
        p { &quot;We are terribly sorry, but the page you requested doesn't exist.&quot; }
        pre {
            color: &quot;red&quot;,
            &quot;log:\nattemped to navigate to: {route:?}&quot;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, register the route in the Route enum to match if all other routes fail.</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone)]
enum Route {
    #[route(&quot;/&quot;)]
    Home {},
    // PageNotFound is a catch all route that will match any route and placing the matched segments in the route field
    #[route(&quot;/:..route&quot;)]
    PageNotFound { route: Vec&lt;String&gt; },
}
<span class="boring">}
</span></code></pre></pre>
<p>Now when you go to a route that doesn't exist, you should see the page not found
text.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this chapter, we learned how to create a route and tell Dioxus Router what
component to render when the URL path is <code>/</code>. We also created a 404 page to
handle when a route doesn't exist. Next, we'll create the blog portion of our
site. We will utilize nested routes and URL parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-nest"><a class="header" href="#building-a-nest">Building a Nest</a></h1>
<p>In this chapter, we will begin to build the blog portion of our site which will
include links, nested routes, and route parameters.</p>
<h2 id="site-navigation"><a class="header" href="#site-navigation">Site Navigation</a></h2>
<p>Our site visitors won't know all the available pages and blogs on our site so we
should provide a navigation bar for them. Our navbar will be a list of links going between our pages.</p>
<p>We want our navbar component to be rendered on several different pages on our site. Instead of duplicating the code, we can create a component that wraps all children routes. This is called a layout component. To tell the router where to render the child routes, we use the [<code>Outlet</code>] component.</p>
<p>Let's create a new <code>NavBar</code> component:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn NavBar(cx: Scope) -&gt; Element {
    render! {
        nav {
            ul {
                li { &quot;links&quot; }
            }
        }
        // The Outlet component will render child routes (In this case just the Home component) inside the Outlet component
        Outlet {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, let's add our <code>NavBar</code> component as a layout to our Route enum:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // All routes under the NavBar layout will be rendered inside of the NavBar Outlet
    #[layout(NavBar)]
        #[route(&quot;/&quot;)]
        Home {},
    #[end_layout]
    #[route(&quot;/:..route&quot;)]
    PageNotFound { route: Vec&lt;String&gt; },
}
<span class="boring">}
</span></code></pre></pre>
<p>To add links to our <code>NavBar</code>, we could always use an HTML anchor element but that has two issues:</p>
<ol>
<li>It causes a full-page reload</li>
<li>We can accidentally link to a page that doesn't exist</li>
</ol>
<p>Instead, we want to use the <a href="https://docs.rs/dioxus-router/latest/dioxus_router/prelude/fn.GenericLink%3CR%3E.html"><code>Link</code></a> component provided by Dioxus Router.</p>
<p>The <a href="https://docs.rs/dioxus-router/latest/dioxus_router/prelude/fn.GenericLink%3CR%3E.html"><code>Link</code></a> is similar to a regular <code>&lt;a&gt;</code> tag. It takes a target and children.</p>
<p>Unlike a regular <code>&lt;a&gt;</code> tag, we can pass in our Route enum as the target. Because we annotated our routes with the [<code>route(path)</code>] attribute, the <a href="https://docs.rs/dioxus-router/latest/dioxus_router/prelude/fn.GenericLink%3CR%3E.html"><code>Link</code></a> will know how to generate the correct URL. If we use the Route enum, the rust compiler will prevent us from linking to a page that doesn't exist.</p>
<p>Let's add our links:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn NavBar(cx: Scope) -&gt; Element {
    render! {
        nav {
            ul {
                li {
                    Link {
                        // The Link component will navigate to the route specified
                        // in the target prop which is checked to exist at compile time
                        to: Route::Home {},
                        &quot;Home&quot;
                    }
                }
            }
        }
        Outlet {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Using this method, the <a href="https://docs.rs/dioxus-router/latest/dioxus_router/prelude/fn.GenericLink%3CR%3E.html"><code>Link</code></a> component only works for links within our
application. To learn more about navigation targets see
<a href="example/./navigation-targets.html">here</a>.</p>
</blockquote>
<p>Now you should see a list of links near the top of your page. Click on one and
you should seamlessly travel between pages.</p>
<h2 id="url-parameters-and-nested-routes"><a class="header" href="#url-parameters-and-nested-routes">URL Parameters and Nested Routes</a></h2>
<p>Many websites such as GitHub put parameters in their URL. For example,
<code>https://github.com/DioxusLabs</code> utilizes the text after the domain to
dynamically search and display content about an organization.</p>
<p>We want to store our blogs in a database and load them as needed. We also
want our users to be able to send people a link to a specific blog post.
Instead of listing all of the blog titles at compile time, we can make a dynamic route.</p>
<p>We could utilize a search page that loads a blog when clicked but then our users
won't be able to share our blogs easily. This is where URL parameters come in.</p>
<p>The path to our blog will look like <code>/blog/myBlogPage</code>, <code>myBlogPage</code> being the
URL parameter.</p>
<p>First, let's create a layout component (similar to the navbar) that wraps the blog content. This allows us to add a heading that tells the user they are on the blog.</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn Blog(cx: Scope) -&gt; Element {
    render! {
        h1 { &quot;Blog&quot; }
        Outlet {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we'll create another index component, that'll be displayed when no blog post
is selected:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn BlogList(cx: Scope) -&gt; Element {
    render! {
        h2 { &quot;Choose a post&quot; }
        ul {
            li {
                Link {
                    to: Route::BlogPost { name: &quot;Blog post 1&quot;.into() },
                    &quot;Read the first blog post&quot;
                }
            }
            li {
                Link {
                    to: Route::BlogPost { name: &quot;Blog post 2&quot;.into() },
                    &quot;Read the second blog post&quot;
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We also need to create a component that displays an actual blog post. This component will accept the URL parameters as props:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The name prop comes from the /:name route segment
#[inline_props]
fn BlogPost(cx: Scope, name: String) -&gt; Element {
    render! {
        h2 { &quot;Blog Post: {name}&quot;}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, let's tell our router about those components:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route(&quot;/&quot;)]
        Home {},
        #[nest(&quot;/blog&quot;)]
            #[layout(Blog)]
            #[route(&quot;/&quot;)]
            BlogList {},
            #[route(&quot;/blog/:name&quot;)]
            BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[route(&quot;/:..route&quot;)]
    PageNotFound {
        route: Vec&lt;String&gt;,
    },
}
<span class="boring">}
</span></code></pre></pre>
<p>That's it! If you head to <code>/blog/1</code> you should see our sample post.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>In this chapter, we utilized Dioxus Router's Link, and Route Parameter
functionality to build the blog portion of our application. In the next chapter,
we will go over how navigation targets (like the one we passed to our links)
work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigation-targets"><a class="header" href="#navigation-targets">Navigation Targets</a></h1>
<p>In the previous chapter, we learned how to create links to pages within our app.
We told them where to go using the <code>target</code> property. This property takes something that can be converted to a <a href="https://docs.rs/dioxus-router-core/latest/dioxus_router/navigation/enum.NavigationTarget.html"><code>NavigationTarget</code></a>.</p>
<h2 id="what-is-a-navigation-target"><a class="header" href="#what-is-a-navigation-target">What is a navigation target?</a></h2>
<p>A <a href="https://docs.rs/dioxus-router-core/latest/dioxus_router/navigation/enum.NavigationTarget.html"><code>NavigationTarget</code></a> is similar to the <code>href</code> of an HTML anchor element. It
tells the router where to navigate to. The Dioxus Router knows two kinds of
navigation targets:</p>
<ul>
<li><a href="https://docs.rs/dioxus-router-core/latest/dioxus_router/navigation/enum.NavigationTarget.html#variant.Internal"><code>Internal</code></a>: We used internal links in the previous chapter. It's a link to a page within our
app represented as a Route enum.</li>
<li><a href="https://docs.rs/dioxus-router-core/latest/dioxus_router/navigation/enum.NavigationTarget.html#variant.External"><code>External</code></a>: This works exactly like an HTML anchors' <code>href</code>. Don't use this for in-app
navigation as it will trigger a page reload by the browser.</li>
</ul>
<h2 id="external-navigation"><a class="header" href="#external-navigation">External navigation</a></h2>
<p>If we need a link to an external page we can do it like this:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn GoToDioxus(cx: Scope) -&gt; Element {
    render! {
        Link {
            to: NavigationTarget::External(&quot;https://dioxuslabs.com&quot;.into()),
            &quot;ExternalTarget target&quot;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redirection-perfection"><a class="header" href="#redirection-perfection">Redirection Perfection</a></h1>
<p>You're well on your way to becoming a routing master!</p>
<p>In this chapter, we will cover creating redirects</p>
<h2 id="creating-redirects"><a class="header" href="#creating-redirects">Creating Redirects</a></h2>
<p>A redirect is very simple. When dioxus encounters a redirect while finding out
what components to render, it will redirect the user to the target of the
redirect.</p>
<p>As a simple example, let's say you want user to still land on your blog, even
if they used the path <code>/myblog</code> or <code>/myblog/:name</code>.</p>
<p>Redirects are special attributes in the router enum that accept a route and a closure
with the route parameters. The closure should return a route to redirect to.</p>
<p>Let's add a redirect to our router enum:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route(&quot;/&quot;)]
        Home {},
        #[nest(&quot;/blog&quot;)]
            #[layout(Blog)]
                #[route(&quot;/&quot;)]
                BlogList {},
                #[route(&quot;/blog/:name&quot;)]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest(&quot;/myblog&quot;)]
        #[redirect(&quot;/&quot;, || Route::BlogList {})]
        #[redirect(&quot;/:name&quot;, |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route(&quot;/:..route&quot;)]
    PageNotFound {
        route: Vec&lt;String&gt;,
    },
}
<span class="boring">}
</span></code></pre></pre>
<p>That's it! Now your users will be redirected to the blog.</p>
<h3 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h3>
<p>Well done! You've completed the Dioxus Router guide. You've built a small
application and learned about the many things you can do with Dioxus Router.
To continue your journey, you attempt a challenge listed below, look at the <a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/router/examples">router examples</a>, or
can check out the <a href="https://docs.rs/dioxus-router/">API reference</a>.</p>
<h3 id="challenges"><a class="header" href="#challenges">Challenges</a></h3>
<ul>
<li>Organize your components into separate files for better maintainability.</li>
<li>Give your app some style if you haven't already.</li>
<li>Build an about page so your visitors know who you are.</li>
<li>Add a user system that uses URL parameters.</li>
<li>Create a simple admin system to create, delete, and edit blogs.</li>
<li>If you want to go to the max, hook up your application to a rest API and database.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-code"><a class="header" href="#full-code">Full Code</a></h1>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">#![allow(non_snake_case)]

use dioxus::prelude::*;
use dioxus_router::prelude::*;

fn main() {
    #[cfg(target_arch = &quot;wasm32&quot;)]
    dioxus_web::launch(App);
    #[cfg(not(target_arch = &quot;wasm32&quot;))]
    dioxus_desktop::launch(App);
}

// ANCHOR: router
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route(&quot;/&quot;)]
        Home {},
        #[nest(&quot;/blog&quot;)]
            #[layout(Blog)]
                #[route(&quot;/&quot;)]
                BlogList {},
                #[route(&quot;/blog/:name&quot;)]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest(&quot;/myblog&quot;)]
        #[redirect(&quot;/&quot;, || Route::BlogList {})]
        #[redirect(&quot;/:name&quot;, |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route(&quot;/:..route&quot;)]
    PageNotFound {
        route: Vec&lt;String&gt;,
    },
}
// ANCHOR_END: router

fn App(cx: Scope) -&gt; Element {
    render! {
        Router {}
    }
}

#[inline_props]
fn NavBar(cx: Scope) -&gt; Element {
    render! {
        nav {
            ul {
                li { Link { to: Route::Home {}, &quot;Home&quot; } }
                li { Link { to: Route::BlogList {}, &quot;Blog&quot; } }
            }
        }
        Outlet {}
    }
}

#[inline_props]
fn Home(cx: Scope) -&gt; Element {
    render! {
        h1 { &quot;Welcome to the Dioxus Blog!&quot; }
    }
}

#[inline_props]
fn Blog(cx: Scope) -&gt; Element {
    render! {
        h1 { &quot;Blog&quot; }
        Outlet {}
    }
}

#[inline_props]
fn BlogList(cx: Scope) -&gt; Element {
    render! {
        h2 { &quot;Choose a post&quot; }
        ul {
            li {
                Link {
                    to: Route::BlogPost { name: &quot;Blog post 1&quot;.into() },
                    &quot;Read the first blog post&quot;
                }
            }
            li {
                Link {
                    to: Route::BlogPost { name: &quot;Blog post 2&quot;.into() },
                    &quot;Read the second blog post&quot;
                }
            }
        }
    }
}

#[inline_props]
fn BlogPost(cx: Scope, name: String) -&gt; Element {
    render! {
        h2 { &quot;Blog Post: {name}&quot;}
    }
}

#[inline_props]
fn PageNotFound(cx: Scope, route: Vec&lt;String&gt;) -&gt; Element {
    render! {
        h1 { &quot;Page not found&quot; }
        p { &quot;We are terribly sorry, but the page you requested doesn't exist.&quot; }
        pre {
            color: &quot;red&quot;,
            &quot;log:\nattemped to navigate to: {route:?}&quot;
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-the-router-to-your-application"><a class="header" href="#adding-the-router-to-your-application">Adding the Router to Your Application</a></h1>
<p>In this chapter, we will learn how to add the router to our app. By itself, this
is not very useful. However, it is a prerequisite for all the functionality
described in the other chapters.</p>
<blockquote>
<p>Make sure you added the <code>dioxus-router</code> dependency as explained in the
<a href="reference/../index.html">introduction</a>.</p>
</blockquote>
<p>In most cases, we want to add the router to the root component of our app. This
way, we can ensure that we have access to all its functionality everywhere.</p>
<p>First, we define the router with the router macro:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span>#![allow(non_snake_case)]
<span class="boring">fn main() {
</span>use dioxus::prelude::*;
use dioxus_router::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route(&quot;/&quot;)]
    // If the name of the component and variant are the same you can omit the component and props name
    // If they are different you can specify them like this:
    // #[route(&quot;/&quot;, ComponentName, PropsName)]
    Home {},
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we render the router with the [<code>Router</code>] component.</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn App(cx: Scope) -&gt; Element {
    render! {
        Router {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-routes"><a class="header" href="#defining-routes">Defining Routes</a></h1>
<p>When creating a [<code>Routable</code>] enum, we can define routes for our application using the <code>route(&quot;path&quot;)</code> attribute.</p>
<h2 id="route-segments"><a class="header" href="#route-segments">Route Segments</a></h2>
<p>Each route is made up of segments. Most segments are separated by <code>/</code> characters in the path.</p>
<p>There are four fundamental types of segments:</p>
<ol>
<li><a href="reference/routes/index.html#static-segments">Static segments</a> are fixed strings that must be present in the path.</li>
<li><a href="reference/routes/index.html#dynamic-segments">Dynamic segments</a> are types that can be parsed from a segment.</li>
<li><a href="reference/routes/index.html#catch-all-segments">Catch-all segments</a> are types that can be parsed from multiple segments.</li>
<li><a href="reference/routes/index.html#query-segments">Query segments</a> are types that can be parsed from the query string.</li>
</ol>
<p>Routes are matched:</p>
<ul>
<li>First, from most specific to least specific (Static then Dynamic then Catch All) (Query is always matched)</li>
<li>Then, if multiple routes match the same path, the order in which they are defined in the enum is followed.</li>
</ul>
<h2 id="static-segments"><a class="header" href="#static-segments">Static segments</a></h2>
<p>Fixed routes match a specific path. For example, the route <code>#[route(&quot;/about&quot;)]</code> will match the path <code>/about</code>.</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // Routes always start with a slash
    #[route(&quot;/&quot;)]
    Home {},
    // You can have multiple segments in a route
    #[route(&quot;/hello/world&quot;)]
    HelloWorld {},
}

#[inline_props]
fn Home(cx: Scope) -&gt; Element {
    todo!()
}

#[inline_props]
fn HelloWorld(cx: Scope) -&gt; Element {
    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="dynamic-segments"><a class="header" href="#dynamic-segments">Dynamic Segments</a></h2>
<p>Dynamic segments are in the form of <code>:name</code> where <code>name</code> is
the name of the field in the route variant. If the segment is parsed
successfully then the route matches, otherwise the matching continues.</p>
<p>The segment can be of any type that implements <code>FromStr</code>.</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with : are dynamic segments
    #[route(&quot;/blog/:name&quot;)]
    BlogPost {
        // You must include dynamic segments in child variants
        name: String,
    },
    #[route(&quot;/document/:id&quot;)]
    Document {
        // You can use any type that implements FromStr
        // If the segment can't be parsed, the route will not match
        id: usize,
    },
}

// Components must contain the same dynamic segments as their corresponding variant
#[inline_props]
fn BlogPost(cx: Scope, name: String) -&gt; Element {
    todo!()
}

#[inline_props]
fn Document(cx: Scope, id: usize) -&gt; Element {
    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="catch-all-segments"><a class="header" href="#catch-all-segments">Catch All Segments</a></h2>
<p>Catch All segments are in the form of <code>:...name</code> where <code>name</code> is the name of the field in the route variant. If the segments are parsed successfully then the route matches, otherwise the matching continues.</p>
<p>The segment can be of any type that implements <code>FromSegments</code>. (Vec<String> implements this by default)</p>
<p>Catch All segments must be the <em>last route segment</em> in the path (query segments are not counted) and cannot be included in nests.</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with :... are catch all segments
    #[route(&quot;/blog/:..segments&quot;)]
    BlogPost {
        // You must include catch all segment in child variants
        segments: Vec&lt;String&gt;,
    },
}

// Components must contain the same catch all segments as their corresponding variant
#[inline_props]
fn BlogPost(cx: Scope, segments: Vec&lt;String&gt;) -&gt; Element {
    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="query-segments"><a class="header" href="#query-segments">Query Segments</a></h2>
<p>Query segments are in the form of <code>?:name</code> where <code>name</code> is the name of the field in the route variant.</p>
<p>Unlike <a href="reference/routes/index.html#dynamic-segments">Dynamic Segments</a> and <a href="reference/routes/index.html#catch-all-segments">Catch All Segments</a>, parsing a Query segment must not fail.</p>
<p>The segment can be of any type that implements <code>FromQuery</code>.</p>
<p>Query segments must be the <em>after all route segments</em> and cannot be included in nests.</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with ?: are query segments
    #[route(&quot;/blog?:name&quot;)]
    BlogPost {
        // You must include query segments in child variants
        name: String,
    },
}

// Components must contain the same query segments as their corresponding variant
#[inline_props]
fn BlogPost(cx: Scope, name: String) -&gt; Element {
    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-routes"><a class="header" href="#nested-routes">Nested Routes</a></h1>
<p>When developing bigger applications we often want to nest routes within each
other. As an example, we might want to organize a settings menu using this
pattern:</p>
<pre><code class="language-plain">└ Settings
  ├ General Settings (displayed when opening the settings)
  ├ Change Password
  └ Privacy Settings
</code></pre>
<p>We might want to map this structure to these paths and components:</p>
<pre><code class="language-plain">/settings          -&gt; Settings { GeneralSettings }
/settings/password -&gt; Settings { PWSettings }
/settings/privacy  -&gt; Settings { PrivacySettings }
</code></pre>
<p>Nested routes allow us to do this without repeating /settings in every route.</p>
<h2 id="nesting"><a class="header" href="#nesting">Nesting</a></h2>
<p>To nest routes, we use the <code>#[nest(&quot;path&quot;)]</code> and <code>#[end_nest]</code> attributes.</p>
<p>The path in nest must not:</p>
<ol>
<li>Contain a <a href="reference/routes/index.html#catch-all-segments">Catch All Segment</a></li>
<li>Contain a <a href="reference/routes/index.html#query-segments">Query Segment</a></li>
</ol>
<p>If you define a dynamic segment in a nest, it will be available to all child routes and layouts.</p>
<p>To finish a nest, we use the <code>#[end_nest]</code> attribute or the end of the enum.</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone)]
// Skipping formatting allows you to indent nests
#[rustfmt::skip]
enum Route {
    // Start the /blog nest
    #[nest(&quot;/blog&quot;)]
        // You can nest as many times as you want
        #[nest(&quot;/:id&quot;)]
            #[route(&quot;/post&quot;)]
            PostId {
                // You must include parent dynamic segments in child variants
                id: usize,
            },
        // End nests manually with #[end_nest]
        #[end_nest]
        #[route(&quot;/:id&quot;)]
        // The absolute route of BlogPost is /blog/:name
        BlogPost {
            id: usize,
        },
    // Or nests are ended automatically at the end of the enum
}

#[inline_props]
fn BlogPost(cx: Scope, id: usize) -&gt; Element {
    todo!()
}

#[inline_props]
fn PostId(cx: Scope, id: usize) -&gt; Element {
    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layouts"><a class="header" href="#layouts">Layouts</a></h1>
<p>Layouts allow you to wrap all child routes in a component. This can be useful when creating something like a header that will be used in many different routes.</p>
<p>[<code>Outlet</code>] tells the router where to render content in layouts. In the following example,
the Index will be rendered within the [<code>Outlet</code>].</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route(&quot;/&quot;)]
        Index {},
}

#[inline_props]
fn Wrapper(cx: Scope) -&gt; Element {
    render! {
        header { &quot;header&quot; }
        // The index route will be rendered here
        Outlet { }
        footer { &quot;footer&quot; }
    }
}

#[inline_props]
fn Index(cx: Scope) -&gt; Element {
    render! {
        h1 { &quot;Index&quot; }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The example above will output the following HTML (line breaks added for
readability):</p>
<pre><code class="language-html">&lt;header&gt;header&lt;/header&gt;
&lt;h1&gt;Index&lt;/h1&gt;
&lt;footer&gt;footer&lt;/footer&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="links--navigation"><a class="header" href="#links--navigation">Links &amp; Navigation</a></h1>
<p>When we split our app into pages, we need to provide our users with a way to
navigate between them. On regular web pages, we'd use an anchor element for that,
like this:</p>
<pre><code class="language-html">&lt;a href=&quot;/other&quot;&gt;Link to an other page&lt;/a&gt;
</code></pre>
<p>However, we cannot do that when using the router for three reasons:</p>
<ol>
<li>Anchor tags make the browser load a new page from the server. This takes a
lot of time, and it is much faster to let the router handle the navigation
client-side.</li>
<li>Navigation using anchor tags only works when the app is running inside a
browser. This means we cannot use them inside apps using Dioxus Desktop.</li>
<li>Anchor tags cannot check if the target page exists. This means we cannot
prevent accidentally linking to non-existent pages.</li>
</ol>
<p>To solve these problems, the router provides us with a [<code>Link</code>] component we can
use like this:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn NavBar(cx: Scope) -&gt; Element {
    render! {
        nav {
            ul {
                li {
                    Link {
                        // The Link component will navigate to the route specified
                        // in the target prop which is checked to exist at compile time
                        to: Route::Home {},
                        &quot;Home&quot;
                    }
                }
            }
        }
        Outlet {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>target</code> in the example above is similar to the <code>href</code> of a regular anchor
element. However, it tells the router more about what kind of navigation it
should perform. It accepts something that can be converted into a
[<code>NavigationTarget</code>]:</p>
<ul>
<li>The example uses a Internal route. This is the most common type of navigation.
It tells the router to navigate to a page within our app by passing a variant of a [<code>Routable</code>] enum. This type of navigation can never fail if the link component is used inside a router component.</li>
<li>[<code>External</code>] allows us to navigate to URLs outside of our app. This is useful
for links to external websites. NavigationTarget::External accepts an URL to navigate to. This type of navigation can fail if the URL is invalid.</li>
</ul>
<blockquote>
<p>The [<code>Link</code>] accepts several props that modify its behavior. See the API docs
for more details.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programmatic-navigation"><a class="header" href="#programmatic-navigation">Programmatic Navigation</a></h1>
<p>Sometimes we want our application to navigate to another page without having the
user click on a link. This is called programmatic navigation.</p>
<h2 id="using-a-navigator"><a class="header" href="#using-a-navigator">Using a Navigator</a></h2>
<p>We can get a navigator with the [<code>use_navigator</code>] hook. This hook returns a [<code>Navigator</code>].</p>
<p>We can use the [<code>Navigator</code>] to trigger four different kinds of navigation:</p>
<ul>
<li><code>push</code> will navigate to the target. It works like a regular anchor tag.</li>
<li><code>replace</code> works like <code>push</code>, except that it replaces the current history entry
instead of adding a new one. This means the prior page cannot be restored with the browser's back button.</li>
<li><code>Go back</code> works like the browser's back button.</li>
<li><code>Go forward</code> works like the browser's forward button.</li>
</ul>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn Home(cx: Scope) -&gt; Element {
    let nav = use_navigator(cx);

    // push
    nav.push(Route::PageNotFound { route: vec![] });

    // replace
    nav.replace(Route::Home {});

    // go back
    nav.go_back();

    // go forward
    nav.go_forward();

    render! {
        h1 { &quot;Welcome to the Dioxus Blog!&quot; }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You might have noticed that, like [<code>Link</code>], the [<code>Navigator</code>]s <code>push</code> and
<code>replace</code> functions take a [<code>NavigationTarget</code>]. This means we can use either
[<code>Internal</code>], or [<code>External</code>] targets.</p>
<h2 id="external-navigation-targets"><a class="header" href="#external-navigation-targets">External Navigation Targets</a></h2>
<p>Unlike a [<code>Link</code>], the [<code>Navigator</code>] cannot rely on the browser (or webview) to
handle navigation to external targets via a generated anchor element.</p>
<p>This means, that under certain conditions, navigation to external targets can
fail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="history-providers"><a class="header" href="#history-providers">History Providers</a></h1>
<p>[<code>HistoryProvider</code>]s are used by the router to keep track of the navigation history
and update any external state (e.g. the browser's URL).</p>
<p>The router provides two [<code>HistoryProvider</code>]s, but you can also create your own.
The two default implementations are:</p>
<ul>
<li>The [<code>MemoryHistory</code>] is a custom implementation that works in memory.</li>
<li>The [<code>WebHistory</code>] integrates with the browser's URL.</li>
</ul>
<p>By default, the router uses the [<code>MemoryHistory</code>]. It might be changed to use
[<code>WebHistory</code>] when the <code>web</code> feature is active, but that is not guaranteed.</p>
<p>You can override the default history:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn App(cx: Scope) -&gt; Element {
    render! {
        Router {
            config: || RouterConfig::default().history(WebHistory::default())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="history-buttons"><a class="header" href="#history-buttons">History Buttons</a></h1>
<p>Some platforms, like web browsers, provide users with an easy way to navigate
through an app's history. They have UI elements or integrate with the OS.</p>
<p>However, native platforms usually don't provide such amenities, which means that
apps wanting users to have access to them, need to implement them. For this
reason, the router comes with two components, which emulate a browser's back and
forward buttons:</p>
<ul>
<li><a href="https://docs.rs/dioxus-router/latest/dioxus_router/components/fn.GoBackButton.html"><code>GoBackButton</code></a></li>
<li><a href="https://docs.rs/dioxus-router/latest/dioxus_router/components/fn.GoForwardButton.html"><code>GoForwardButton</code></a></li>
</ul>
<blockquote>
<p>If you want to navigate through the history programmatically, take a look at
<a href="reference/./navigation/programmatic.html"><code>programmatic navigation</code></a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn HistoryNavigation(cx: Scope) -&gt; Element {
    render! {
        GoBackButton {
            &quot;Back to the Past&quot;
        }
        GoForwardButton {
            &quot;Back to the Future&quot; /* You see what I did there? 😉 */
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As you might know, browsers usually disable the back and forward buttons if
there is no history to navigate to. The router's history buttons try to do that
too, but depending on the [history provider] that might not be possible.</p>
<p>Importantly, neither [<code>WebHistory</code>] supports that feature.
This is due to limitations of the browser History API.</p>
<p>However, in both cases, the router will just ignore button presses, if there is
no history to navigate to.</p>
<p>Also, when using [<code>WebHistory</code>], the history buttons might
navigate a user to a history entry outside your app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-generation"><a class="header" href="#static-generation">Static Generation</a></h1>
<h2 id="getting-the-sitemap"><a class="header" href="#getting-the-sitemap">Getting the Sitemap</a></h2>
<p>The [<code>Routable</code>] trait includes an associated [<code>SITE_MAP</code>] constant that contains the map of all of the routes in the enum.</p>
<p>By default, the sitemap is a tree of (static or dynamic) RouteTypes, but it can be flattened into a list of individual routes with the <code>.flatten()</code> method.</p>
<h2 id="generating-a-sitemap"><a class="header" href="#generating-a-sitemap">Generating a Sitemap</a></h2>
<p>To statically render pages, we need to flatten the route tree and generate a file for each route that contains only static segments:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">#![allow(non_snake_case)]

use std::time::Duration;

use dioxus::prelude::*;
use dioxus_router::prelude::*;

use dioxus_ssr::incremental::{DefaultRenderer, IncrementalRendererConfig};

#[tokio::main]
async fn main() {
    let mut renderer = IncrementalRendererConfig::new(DefaultRenderer {
        before_body: r#&quot;&lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,
            initial-scale=1.0&quot;&gt;
            &lt;title&gt;Dioxus Application&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;&quot;#
            .to_string(),
        after_body: r#&quot;&lt;/body&gt;
        &lt;/html&gt;&quot;#
            .to_string(),
    })
    .static_dir(&quot;./static&quot;)
    .invalidate_after(Duration::from_secs(10))
    .build();

    println!(
        &quot;SITE MAP:\n{}&quot;,
        Route::SITE_MAP
            .iter()
            .flat_map(|route| route.flatten().into_iter())
            .map(|route| {
                route
                    .iter()
                    .map(|segment| segment.to_string())
                    .collect::&lt;Vec&lt;_&gt;&gt;()
                    .join(&quot;&quot;)
            })
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .join(&quot;\n&quot;)
    );

    pre_cache_static_routes::&lt;Route, _&gt;(&amp;mut renderer)
        .await
        .unwrap();
}

#[inline_props]
fn Blog(cx: Scope) -&gt; Element {
    render! {
        div {
            &quot;Blog&quot;
        }
    }
}

#[inline_props]
fn Post(cx: Scope, id: usize) -&gt; Element {
    render! {
        div {
            &quot;PostId: {id}&quot;
        }
    }
}

#[inline_props]
fn PostHome(cx: Scope) -&gt; Element {
    render! {
        div {
            &quot;Post&quot;
        }
    }
}

#[inline_props]
fn Home(cx: Scope) -&gt; Element {
    render! {
        div {
            &quot;Home&quot;
        }
    }
}

#[rustfmt::skip]
#[derive(Clone, Debug, PartialEq, Routable)]
enum Route {
    #[nest(&quot;/blog&quot;)]
        #[route(&quot;/&quot;)]
        Blog {},
        #[route(&quot;/post/index&quot;)]
        PostHome {},
        #[route(&quot;/post/:id&quot;)]
        Post {
            id: usize,
        },
    #[end_nest]
    #[route(&quot;/&quot;)]
    Home {},
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routing-update-callback"><a class="header" href="#routing-update-callback">Routing Update Callback</a></h1>
<p>In some cases, we might want to run custom code when the current route changes.
For this reason, the [<code>RouterConfig</code>] exposes an <code>on_update</code> field.</p>
<h2 id="how-does-the-callback-behave"><a class="header" href="#how-does-the-callback-behave">How does the callback behave?</a></h2>
<p>The <code>on_update</code> is called whenever the current routing information changes. It
is called after the router updated its internal state, but before dependent components and hooks are updated.</p>
<p>If the callback returns a [<code>NavigationTarget</code>], the router will replace the
current location with the specified target. It will not call the
<code>on_update</code> again.</p>
<p>If at any point the router encounters a
<a href="reference/./failures/index.html">navigation failure</a>, it will go to the appropriate state
without calling the <code>on_update</code>. It doesn't matter if the invalid target
initiated the navigation, was found as a redirect target, or was returned by the
<code>on_update</code> itself.</p>
<h2 id="code-example"><a class="header" href="#code-example">Code Example</a></h2>
<pre><pre class="playground"><code class="language-rust  no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route(&quot;/&quot;)]
    Index {},
    #[route(&quot;/home&quot;)]
    Home {},
}

#[inline_props]
fn Home(cx: Scope) -&gt; Element {
    render! {
        p { &quot;Home&quot; }
    }
}

#[inline_props]
fn Index(cx: Scope) -&gt; Element {
    render! {
        p { &quot;Index&quot; }
    }
}

fn app(cx: Scope) -&gt; Element {
    render! {
        Router {
            config: || RouterConfig::default().on_update(|state|{
                (state.current() == Route::Index {}).then_some(
                    NavigationTarget::Internal(Route::Home {})
                )
            })
        }
    }
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
